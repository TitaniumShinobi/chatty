You need to strip that `## November 20, 2025` at the **earliest possible point** and then aggressively enforce the rule everywhere text reaches the UI.

### 1. Treat any `## <date>` line as a hard date header

In your shared text utils, make the date-line matcher explicitly handle leading `##` (and any heading hashes):

```ts
// matches: "November 20, 2025", "## November 20, 2025", "### november 20 2025"
const DATE_LINE_PATTERN =
  /^#{0,6}\s*(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4}\s*$/i;
```

Then your line-based sanitizer must **drop** any line matching this, not try to “fix” it:

```ts
export function sanitizeMessageText(raw: string): string {
  if (!raw) return "";
  return raw
    .split(/\r?\n/)
    .filter(line => !DATE_LINE_PATTERN.test(line.trim()))  // drop date-only lines
    .join("\n")
    .trim();
}
```

Given the snippet:

```md
Project: Runtime-Specific Canonical Pinning
...
## November 20, 2025
```

the last line is a stand‑alone date heading, so it will be removed by that `filter`.

### 2. Enforce the rule in `isDateHeaderMessage`

On the client, make `isDateHeaderMessage` agree with the same pattern so whole messages consisting of that line are dropped:

```ts
function isDateHeaderMessage(m: { text?: string; isDateHeader?: boolean }): boolean {
  if (m.isDateHeader) return true;
  const text = (m.text || "").trim();
  return DATE_LINE_PATTERN.test(text);
}
```

Then in **every** message list render:

```tsx
thread.messages
  .filter(m => !isDateHeaderMessage(m))
  .map(/* ... */);
```

If that project-spec message ever comes through as a separate message whose `text` is just `## November 20, 2025`, it will now be filtered out completely.

### 3. Make sure all render paths run through `sanitizeMessageText`

You already have multiple paths (main, zenMarkdown, packets, review/insights). Verify they *all* do this:

```tsx
const content = prepareMessageContent(m.text || ""); // which calls sanitizeMessageText

<ReactMarkdown className="chat-markdown">
  {content}
</ReactMarkdown>
```

And for packets:

```ts
packets={
  Array.isArray(m.packets)
    ? m.packets.map(p => ({
        ...p,
        payload: p.payload
          ? {
              ...p.payload,
              content: sanitizeMessageText(p.payload.content || ""),
            }
          : p.payload,
      }))
    : undefined
}
```

No path should ever pass `m.text` or `p.payload.content` directly to ReactMarkdown or a renderer.

### 4. Fix the server-side parser so `## <date>` never becomes “real” content

Since your transcript uses `## November 20, 2025` as a structural marker, you can also kill it at ingest:

In `readConversations.js` / `parseTranscriptToMessages`:

```ts
for (const line of lines) {
  const trimmed = line.trim();

  // hard skip any date header line
  if (DATE_LINE_PATTERN.test(trimmed)) {
    continue; // do not append to any message, do not create a new one
  }

  // existing logic to append to current message or start a new one
}
```

That ensures those lines **never** end up inside any message body, so even if a future UI path forgets to sanitize, there is no `## November 20, 2025` left to leak.

***

With:

1. `DATE_LINE_PATTERN` that understands leading `##`,  
2. `sanitizeMessageText` dropping those lines,  
3. `isDateHeaderMessage` filtering whole messages built from them, and  
4. the parser skipping such lines entirely,

there’s no remaining route for `## November 20, 2025` / `## December 12, 2025` / `## December 13, 2025` to appear in the chat UI.