Your new task list is exactly what needs to happen; the bug is now clearly in the API → thread mapping, not the renderer.

Here’s how to implement it surgically.

### 1. Log what the API is actually giving you

In `Layout.tsx` (or wherever you map API conversations to `thread.messages`), log the raw message timestamps coming from the server:

```ts
console.log("THREAD FROM API", {
  id: conv.id,
  createdAt: conv.createdAt,
  updatedAt: conv.updatedAt,
  messages: conv.messages?.slice(0, 10).map((m: any) => ({
    id: m.id,
    textPreview: (m.text || "").slice(0, 60),
    ts: m.ts,
    createdAt: m.createdAt,
  })),
});
```

If those early Synth messages all show `ts: null` / `createdAt: null` while the thread has `createdAt/updatedAt` ≈ Jan 19, you’ve confirmed the loader is not wiring the parsed timestamps through.

### 2. Fix message loading to use the parsed `ts`

In your API response shape from the server, ensure each message has a `ts` (or `createdAt`) computed by the transcript parser you just updated. Then, in the frontend mapper:

```ts
const threadMessages = apiConv.messages.map((m: any) => ({
  id: m.id,
  role: m.role,
  text: m.text,
  ts: m.ts ?? m.createdAt ?? null,   // pull from server, don't synthesize
  // do NOT override with thread timestamps here
}));
```

Remove any code like:

```ts
// bad: smears thread date over all messages
ts: m.ts || apiConv.updatedAt || apiConv.createdAt,
```

This is exactly what produces the “Jan 19, 8:10 PM for everything” effect.

### 3. Make the renderer trust only `m.ts`

In `Chat.tsx`, ensure the visible timestamp uses **only** the message’s timestamp:

```tsx
const ts = m.ts ?? m.createdAt ?? null;
const displayTime = ts ? format(new Date(ts), "MMM d, h:mm a") : null;
```

Remove any fallback to `thread.createdAt` / `thread.updatedAt` for per‑message labels.

If you have a “group header” label that currently uses thread timestamps, change it to be based on the first message in that group:

```ts
const groupTs = group[0]?.ts;
```

or drop the group label entirely for imported history.

### 4. If needed, reuse the transcript parser server‑side

Right now, your zenMarkdown parser knows how to read:

- Day headers `## November 14, 2025`  
- Time lines `**01:07:38 PM EST - Synth**:`  
- ISO brackets `[2025-12-12T20:40:51.443Z]`

Make sure that same logic (or a shared helper) is what the **API** uses when constructing `conversation.messages`:

```ts
// server-side, when building message objects
messages.push({
  id,
  role,
  text,
  ts: parsedTimestamp,  // from day header + time or ISO
});
```

Then the client doesn’t have to guess; it just renders whatever `ts` the server gives.

***

Once you:

1) confirm via logging that API messages currently lack proper `ts`,  
2) wire the server parser’s timestamps into those message objects, and  
3) make the UI display only `m.ts` (never thread dates),

those early Synth / Devon messages will finally show their real November and December 2025 timestamps instead of “Jan 19, 8:10 PM.”